% testings the HBI models 

% add code (model itself) to the path
addpath(genpath(fullfile(pwd,'codes')))


%% EXAMPLE 1 - BANDIT TASK

% add RL_task dir to the path (badit-task directory)
addpath(genpath(fullfile(pwd,'example_RL_task')))

% load data (from 40 subs) -- cell of structures for 40 subjects
fdata   = load('all_data.mat');
data    = fdata.data;

clear fdata % no need to keep that in the workspace

% data for each subject include: actions and outcomes for those actions
% first let's test the model by using the data from subj 1
subj1   = data{1,1};                    % subj struct
params  = randn(1,2);                   % parameters for that subj
params2 = randn(1,3);                   % parameters for that subj for dual alpha model
f1      = model_RL(params,subj1);       % run model with 1 learning rate (and 1 beta param)
f2      = model_dualRL(params2,subj1);  % run model with 2 learning rates (and 1 beta param)

%%% QUESTION: output of model_RL and model_dualRL is just the posterior?
%%% %%%

%%% QUESTION 2: in both f1 and f2 cases the posterior (or output) is
%%% negative... should it always be negative? why is it negative? 

%%
% try with more extreme param values
params1     = [-10 10];
params2     = [-10 10 10];
f1_ex       = model_RL(params1,subj1);  
f2_ex       = model_dualRL(params2,subj1);  

% outputs f1 and f2 should be negative scalers 
% clear workspace
clear f1 f2 params params2 params1 subj1

%% RUN CBM_LAP -- FIT MODEL TO DATA

% cbm_lap fits every model to each subject data seperately (non-hierachical
% fashion), it employs laplace approximation and needs a normal prior for
% every parameter -- prior mean:0 prior var:6.25 for every param

v               = 6.25;
prior_RL        = struct('mean',zeros(2,1), 'variance',v); % dimensions of mean 2x1
prior_dualRL    = struct('mean',zeros(3,1), 'variance',v); % dimensions of mean 3x1

% specify file address for saving the output of each model:
fname_RL = 'lap_RL.mat';
fname_dualRL = 'lap_dualRL.mat';

% run cbm_lap for each model
% start with RL model
simple_out = cbm_lap(data, @model_RL, prior_RL, fname_RL);

% run cbm for the model_dualRL version
dual_out = cbm_lap(data, @model_dualRL, prior_dualRL, fname_dualRL);

%%% look at the output files 
% fname = load('lap_RL.mat');
% cbm = fname.cbm;
% cbm.output.parameters 

%%% output parameters are for alpha (column 1) and for beta (column 2)

%% RUN CBM_HBI -- FIT MODEL TO DATA 

% now we can run hierarchical bayesian inference using cbm_hbi
% this needs 4 parameters/inputs:
% data, models to run, file-addresses of the cbm_lap outputs, and file
% address to save hbi output

% input 1: data of all subjects
fdata       = load('all_data.mat');
data        = fdata.data;

% input 2: cell input containing function handle to models
models      = {@model_RL, @model_dualRL};

% input 3: file-addresses to files saved by cbm_lap
fcbm_maps   = {'lap_RL.mat', 'lap_dualRL.mat'};

% or..
% fcbm_maps   = {simple_out, dual_out}; same thing as above 

% input 4: a file address to save the output 
fname_hbi   = 'hbi_RL_dualRL.mat';

% now run cbm_hbi 
hbi_out     = cbm_hbi(data, models, fcbm_maps, fname_hbi);

% output:
% model frequency: estimate of how many datasets (subjects) are explained
% by each model -- seems like model 2 performs better

% take a look at the output
fname_hbi   = load('hbi_RL_dualRL.mat'); % can also jus use "hbi_out"
cbm         = fname_hbi.cbm;
cbm.output

% plot the data:
fname_hbi           = 'hbi_RL_dualRL.mat';              % file address
model_names         = {'RL', 'Dual RL'};                % cell with model names
param_names         = {'alpha^+', 'alpha^-', '\beta'};  % cell with parameter names of the winning model
transform           = {'sigmoid', 'sigmoid', 'exp'};    % 

cbm_hbi_plot(fname_hbi, model_names, param_names, transform)

% extract values of individual params:
params_rl           = cbm.output.parameters{1};
params_rl_dual      = cbm.output.parameters{2};

% look at the responsibility generated by each model (should sum to 1
% across models)
responsibility      = cbm.output.responsibility;

% plot responsibility 
% remember that simulated data for the first 10 participants were created
% using the RL model and for the next 30 subjects using the dual RL model
plot(responsibility(:,2)); ylim([-0.1 1.1])

% the xp (exceedance probability) is normally used for model selection
xp      = cbm.output.exceedance_prob;
pxp     = cbm.output.protected_exceedance_prob; % this takes into account that any difference between model 
% frequencies is due to chance

% re-run HBI under prior null hypothesis 
hbi_out2 = cbm_hbi_null(data, fname_hbi);
pxp = hbi_out2.output.protected_exceedance_prob;

%% EXAMPLE 2 - TWO-STEP MARKOV DECISION TASK

clear all
clc






